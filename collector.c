#pragma config(Sensor, S1,     light1,         sensorLightActive)
#pragma config(Sensor, S2,     light2,         sensorLightActive)
#pragma config(Sensor, S3,     HTAC,           sensorI2CCustom)
#pragma config(Motor,  motorA,          A,             tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          B,             tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          C,             tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define SV1 SensorValue[S1]
#define SV2 SensorValue[S2]

#include "hitechnic-accelerometer.h"

void waitStart()
{
	ClearMessage();
	int my_message = message;
	while (my_message == 0)
	{
		ClearMessage();
		my_message = message;
		wait1Msec(1);
	}
}

void motorSync(int k, int v)
{
	int u = k * (nMotorEncoder[C] - nMotorEncoder[B]);
	motor[B] = v + u;
	motor[C] = v - u;
	wait1Msec(1);
}

int g1, g2, est;

void line_traveling(int k, int v, int a)
{
	float e=SV1-g1;
	float u=e*k+e*e*e*0.05;
	motor[motorB]=v+u;
	motor[motorC]=v-u-30;
	motor[motorA]=a;
	wait1Msec(1);

}

int normx;
int nil;

task main()
{
	//TODO check battery charge
	waitStart();
	if (!HTACreadAllAxes(HTAC, normx, nil, nil)) {
      nxtDisplayTextLine(4, "ERROR!!");
      wait1Msec(2000);
      StopAllTasks();
    }
	int blue=0;

	int go=0;
	int red=0, e, u;

	//SensorValue[S1]=0;
	//SensorValue[S2]=0;
	g1=SV1+7;
	g2=SV2+7;
	est = g1 - g2;
	wait1Msec(1000);
	ClearTimer(T1);

	while (SV2 <= g2 && !blue || time1[T1] <= 1000) // traveling by line to first cross
	{
		line_traveling(15, 100, 70);
		nxtDisplayTextLine (1, "e=%d", e);
		nxtDisplayTextLine (3, "SV1=%d", SV1);
		nxtDisplayTextLine (5, "g1=%d", g1);
		nxtDisplayTextLine (7, "u=%d", u);
		if (SV2 > g2 && !blue)
		{
			motor[B] = motor[C] = 0;
			wait1Msec(1000);
			ClearTimer(T1);
			blue = 1;
		}
	}
	motor[motorA]=0;
	motor[motorB]=0;
	motor[motorC]=0;
	PlaySound(soundBeepBeep);
	wait1Msec(1000);
	nMotorEncoder[motorB]=0;
	nMotorEncoder[motorC]=0;
	ClearTimer(T1);


	int x;
	ClearTimer(T1);
	while (SV2 <= g2)
	{
		line_traveling(15, 100, 0);
		wait1Msec(1);
	}

	while (normx - x <= 20) //traveling by line to second cross
	{
		e=SV1-SV2-est;
		u=e*4;
		motor[B]=100+u;
		motor[C]=100-u;
		HTACreadAllAxes(HTAC, x, nil, nil);
		wait1Msec(1);
	}
	motor[B] = motor[C] = 0;
	wait1Msec(1000);
	nMotorEncoder[B] = nMotorEncoder[C] = 0;
	motor[A] = -70;
	wait1Msec(1000);
	motor[A] = 0;
	while (1)
	{
		motorSync(2, -100);
		HTACreadAllAxes(HTAC, x, nil, nil);
		if (x - normx > 20)
			break;
	}
	wait1Msec(1000);
	while (1)
	{
		motorSync(2, -75);
		HTACreadAllAxes(HTAC, x, nil, nil);
		if (abs(x - normx) < 5)
			break;
	}
	nMotorEncoder[B] = 0;
	while (nMotorEncoder[B] > -1000)
	{
		motorSync(2, -75);
	}
	nMotorEncoder[B] = 0;
	motor[B] = -75;
	motor[C] = 75;
	while (nMotorEncoder[B] > -250)
		wait1Msec(1);
	nMotorEncoder[B] = 0;
	while (nMotorEncoder[B] < 1000)
		motorSync(2, 75);
	nMotorEncoder[B] = 0;
	motor[B] = 75;
	motor[C] = -75;
	while (nMotorEncoder[B] < 250)
		wait1Msec(1);
	nMotorEncoder[B] = 0;
	while (nMotorEncoder[B] < 1000)
		motorSync(2, 75);
}
